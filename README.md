# React internals

### СОДЕРЖАНИЕ
- [краткая суть](#краткая-суть)
- [определения](#определения)
- [мысли](#мысли)
### КРАТКАЯ СУТЬ

### ОПРЕДЕЛЕНИЯ
  Реконсилиация
  FiberRoot - механизм переключения между current & workInProgress tree
  RootFiber - аналог document, также известен как HostRoot, корневая нода fiber дерева
  fiber - нить, виртуальый DOM, состоящий из fiberNode
  fiberNode - элемент вирутального DOM
  StateNode
  children - в контексте реального DOM дерева, вложенные теги первого уровня (прямые потомки)
  child - в контексте реального DOM дерева, все узлы первого уровня, включая комменты, текстовые узлы и т.д.
  tag - тип fiberNode

### МЫСЛИ

есть 4 дерева
  - дерево реакт элементов
  - дерево fiber current
  - дерево fiber workInProgress
  - дерево DOM

у DOM узла есть добалвенные свойства от react. Они соедржат
  - соответствующую fiber node
  - события, которые были приреплены к DOM узлу самим реактом

div#root специально как-то помечается реактом. Возможно для отслеживание
его уникальности.

Перед отрисовкой приложения в div#root этот div#root вычищается от 
внутреннего содержимого, включая и children и childs

Есть tag, который собой представляет тип fiber node. 

Fiber root создается двумя частями. RootFiber(HostRoot, tag: 3) & FiberRoot. Они повязываются через свойства FiberRoot.current = RootFiber & RootFiber.stateNode = FiberRoot.

Содержимое FiberNode больше, чем содержимое ReactElement.

Много константных вспомогатедбных значений расположено в замыкании.

Чтобы понимать код реакта, надо познакомиться с пониманием бинарных операций.

Увидели процесс создания корня файберового дерева, на него потом насадятся листики, а потом эта структура уйдет на отрисовку реальным домом. 

В реакте часто видим применение побитовых операторов, это уведичивается производительность. Т.к. побитовые операторы малоинформативны, они именованы понятными константами на английском языке. подробнее тыкать [сюда](https://learn.javascript.ru/bitwise-operators). 

В процессе debugger Chrome есть разные управляющие стрелки:
- F9 (step), шаг машинного выполнения/логики (с учетом асинхронности)
- F11 (Step into), углубиться во вложенную функцию
- Shift + F11 (Step out), выйти из вложенной функции
- F10 (Step over), идти по коду, не углубляясь в другие функции

Реат можнт работать в разных режимах, они имеются контекстом. Для разных режимов заведено 6 или 7 позиций бинарного числа. 21152 - строка, где объявляются контексты. Отсутствие контекста - ноль (NoContext). 

executionContext &= ~BatchedContext //  из текущего executionContext исключается BatchedContext
executionContext |= LegacyUnbatchedContext // добавляет LegacyUnbatchedContext в executionContext

Мы отслеживаем состояние момента выполнения программы через битовую маску.

update - инструкция/информация алгоритму реконсилиации для выращивание fiber дерева, которое потом првератится в DOM.

В фазе реконсилиации есть 2 процесса для каждого файбера: beginWork & completeWork. 

Перед тем, как начанется фаза реконсилиации клонируется HostROOT.

Есть baseState, который с update.queue производит операции над state, update, props. Как, пока не понятно.

Update next (как и итератор) указывает на следующий update. Ссылка next самого последнего update указывает на самый первый из этой очереди. 

У любого fiberNode есть по пути updateQueue.shared.pending есть ссылка на самый последний update в очереди.

!!! Требует уточнения. Со слов Абрамова pushHostRootContext нужен для того, чтобы ориентироваться, находимся ли мы в svg.

___________________________________________________________________________________________________

Описание рис.1 createElement

Люди привыкли воспринимать JSX как html с возможностью встраивать JS, а на самом деле JSX это JS с расширенным синтаксисом, о чем свидетельствует даже само определение (JS Extension). 

JSX представлен тегами, они похожи на html внешне, но воспринимать их как html теги - ошибка, это код который будет преобразован с помощью Babel в чистый js. Основная функция преобразованного js - React.CreateElement. Если не будет Babel, то теги не будут восприняты преобразованы корректно в функцию.

CreateElement принимает три параметра, первый обязательный, два опциональных. 1 - какой  тег(тип), 2 - пропсы, 3 - children. 

В результате работы CreateElement вернется реакт объект с полями. Определяющими будут свойства key, ref, type, props, $$typeof. Свойство $$typeof - отличительное свойство реакт элемент, по которому его идентифицируют.  

Приложения...
В качестве типа можно передать что угодно, не только теги. Строки и числа будут преобразованы ReactDOM в fiberNode, а булевы значения нет. 

Так как children являются внутренним содержимым тега и относятся к props, то мы можем через второй параметр сразу передать третий в виде конструкции: {props: children: 'some text' }.

___________________________________________________________________________________________________

Описание рис.2 reactRoot

Имеется разделение на 2 библиотеки: React & ReactDOM. Изначально это была единая библиотека, разделение произошло позднее по причине того, что библиотеки отвечают за разное назначение. Задача React - предоставляет api для построения дерева react элементов. ReactDOM необходим для постяроения fiber дерева и построения DOM дерева на его основе.

Есть 4 типа деревьев. Дерево реакт узлов, дерево fiber узлов двух типов (current & workInProgress) и DOM дерево.

ReactDOM обладает множеством методов, нас прежде всего интересует метод render. Он принимает 2 аргумента: что мы рендерить и куда. Первый параметр ожидается в виде реакт элемента, второй параметр в виде корневого узла DOM, куда мы отренедерим наш реакт элемент.

Реакт элемент - это объект с рис.1 с полями, определяющим из которых является $$typeof.

В качестве первого параметра метода render можно прокинуть реакт элемент (в таком случае нам понадобится Babel для перевода его в js код), можно прокинуть объект реакт элемента с определяющим полем $$typeof, можно прокинуть тег, можно прокинуть результат выполнения функции возвращающий тег.

// To-do записать определение компонента и про render(<App />)

Приложения...

Для мобильных устройств вместо ReactDOM будет использован React Native.

В метод render можно прокидывать cb третьим параметром, которое вызовется после того, как произойдет render.




